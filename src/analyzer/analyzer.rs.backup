use crate::respository::Repository;
use crate::respository::RepositoryWrapper;
use crate::config::ChainConfig;
use crate::notification::sqs_client::SqsNotifier;
use std::sync::Arc;
use std::collections::HashMap;
use log::{error, info, warn};
use tokio::sync::mpsc::Receiver;
use rust_decimal::Decimal;
use crate::types::BlockData;

#[cfg(feature = "leveldb-backend")]
use leveldb::database::Database as LevelDB;

#[cfg(feature = "rocksdb-backend")]
use crate::respository::is_monitored_address_in_rocksdb;
#[cfg(feature = "rocksdb-backend")]
use rocksdb::DB as RocksDB;

// Unified database type for conditional compilation
#[cfg(feature = "leveldb-backend")]
pub type KeyValueDB = LevelDB;

#[cfg(feature = "rocksdb-backend")]
pub type KeyValueDB = RocksDB;

#[cfg(not(any(feature = "leveldb-backend", feature = "rocksdb-backend")))]
pub type KeyValueDB = ();

#[derive(Debug, Clone)]
struct DepositInfo {
  address: String,
  tx_hash: String,
  block_number: u64,
  amount: String,
  amount_decimal: Option<Decimal>,
}

pub async fn run_analyzer(
  mut receiver: Receiver<BlockData>,
  repository: Arc<RepositoryWrapper>,
  kv_db: Option<Arc<KeyValueDB>>,
  sqs_notifier: Option<Arc<SqsNotifier>>,
  chain_configs: HashMap<String, ChainConfig>,
) {
  info!("[Analyzer] Starting loop...");

  while let Some(block_data) = receiver.recv().await {
    info!("[Analyzer] Î∏îÎ°ù Îç∞Ïù¥ÌÑ∞ ÏàòÏã†! Î∂ÑÏÑù ÏãúÏûë...");
    let repository_clone = repository.clone();
    let kv_db_clone = kv_db.clone();
    let sqs_clone = sqs_notifier.clone();

    // Î∏îÎ°ù Î∂ÑÏÑù Î∞è Í≥†Í∞ù Ï£ºÏÜå Îß§Ïπ≠ (KeyValueDB ÎòêÎäî Repository ÏÇ¨Ïö©)
    let result = analyze_block(block_data, &repository_clone, kv_db_clone.as_deref()).await;

    match result {
      Ok((chain_name, block_number, deposits)) => {
        info!(
          "[Analyzer] Finished processing {} block {}, found {} deposits",
          chain_name, block_number, deposits.len()
        );

        // Get chain config for required confirmations
        let required_confirmations = chain_configs.get(&chain_name.to_uppercase())
          .or_else(|| chain_configs.get(&chain_name.to_lowercase()))
          .map(|c| c.required_confirmations)
          .unwrap_or(12); // Default to 12 if not found

        // ?? ??
        for deposit in deposits {
          if let Err(e) = process_deposit(
            &repository_clone,
            &chain_name,
            deposit,
            block_number,
            required_confirmations,
            sqs_clone.as_deref(),
          ).await {
            error!("[Analyzer] Failed to process deposit: {}", e);
          }
        }

        // ??? ?? ?? ????
        if let Err(e) = repository_clone.update_last_processed_block(&chain_name, block_number).await {
          error!(
            "[Analyzer] Failed to update last processed block for {} block {}: {}",
            chain_name, block_number, e
          );
        }
      }
      Err(e) => {
        error!("[Analyzer] ‚ùå Î∏îÎ°ù Î∂ÑÏÑù Ïã§Ìå®: {}", e);
      }
    }
  }

  info!("[Analyzer] Loop finished because the channel was closed.");
}

async fn analyze_block(
  block_data: BlockData,
  repository: &Arc<RepositoryWrapper>,
  kv_db: Option<&KeyValueDB>,
) -> Result<(String, u64, Vec<DepositInfo>), String> {
  match block_data {
    BlockData::Ethereum(block) => analyze_ethereum_block(block, repository, kv_db).await,
    BlockData::Bitcoin(block) => analyze_bitcoin_block(block, repository, kv_db).await,
    BlockData::Tron(block) => analyze_tron_block(block, repository, kv_db).await,
    BlockData::Theta(block) => analyze_theta_block(block, repository, kv_db).await,
    BlockData::Icon(block) => analyze_icon_block(block, repository, kv_db).await,
    BlockData::Aion(block) => analyze_aion_block(block, repository, kv_db).await,
    BlockData::Algorand(block) => analyze_algorand_block(block, repository, kv_db).await,
    BlockData::Gxchain(block) => analyze_gxchain_block(block, repository, kv_db).await,
    BlockData::Quark(block) => analyze_quark_block(block, repository, kv_db).await,
    BlockData::Terra(block) => analyze_terra_block(block, repository, kv_db).await,
    BlockData::Tezos(block) => analyze_tezos_block(block, repository, kv_db).await,
    BlockData::Wayki(block) => analyze_wayki_block(block, repository, kv_db).await,
  }
}

// Ï£ºÏÜåÍ∞Ä Í¥ÄÎ¶¨ ÎåÄÏÉÅÏù∏ÏßÄ ÌôïÏù∏ (KeyValueDB Ïö∞ÏÑ†, ÏóÜÏúºÎ©¥ Repository ÏÇ¨Ïö©)
async fn is_monitored_address(
  repository: &Arc<RepositoryWrapper>,
  kv_db: Option<&KeyValueDB>,
  address: &str,
  chain_name: &str,
) -> Result<bool, String> {
  // KeyValueDBÍ∞Ä ÏûàÏúºÎ©¥ Í≥†ÏÜç Ï°∞Ìöå (Î®ºÏ†Ä ÏãúÎèÑ)
  #[cfg(feature = "rocksdb-backend")]
  if let Some(kv_db) = kv_db {
    if let Ok(is_monitored) = is_monitored_address_in_rocksdb(kv_db, address, chain_name) {
      return Ok(is_monitored);
    }
  }

  #[cfg(not(feature = "rocksdb-backend"))]
  let _ = kv_db; // unused variable warning Î∞©ÏßÄ

  // KeyValueDBÍ∞Ä ÏóÜÍ±∞ÎÇò KeyValueDBÏóê ÏóÜÏúºÎ©¥ Repository Ï°∞Ìöå
  repository.is_monitored_address(address, chain_name).await
    .map_err(|e| format!("Failed to check if address is monitored: {}", e))
}

async fn analyze_ethereum_block(
  block: crate::coin::ethereum::model::EthereumBlock,
  repository: &Arc<RepositoryWrapper>,
  kv_db: Option<&KeyValueDB>,
) -> Result<(String, u64, Vec<DepositInfo>), String> {
  let chain_name = "ETH";
  let result = block.result.ok_or("Missing 'result' in EthereumBlock")?;
  
  let number_hex = result.number.trim();
  let block_number = if number_hex.starts_with("0x") {
    u64::from_str_radix(&number_hex[2..], 16)
  } else {
    number_hex.parse::<u64>()
  }.map_err(|e| format!("Failed to parse ETH block number: {}", e))?;
  
  info!("[Analyzer] üîç Î∏îÎ°ù #{} Ïä§Ï∫î Ï§ë... (Ìä∏ÎûúÏû≠ÏÖò: {}Í∞ú)", block_number, result.transactions.len());

  let mut deposits = Vec::new();
  let mut checked_count = 0;

  for tx in &result.transactions {
    if let Some(to_address) = &tx.to {
      checked_count += 1;
      if let Ok(true) = is_monitored_address(repository, kv_db, to_address, chain_name).await {
        let amount_hex = tx.value.as_deref().unwrap_or("0x0");
        let amount_decimal = parse_wei_to_decimal(amount_hex).ok();

        info!("[Analyzer] ‚úÖ ÏûÖÍ∏à Í∞êÏßÄ! Î∏îÎ°ù: {} | Ï£ºÏÜå: {} | Í∏àÏï°: {:?} ETH",
          block_number, to_address, amount_decimal);

        deposits.push(DepositInfo {
          address: to_address.clone(),
          tx_hash: tx.hash.as_deref().unwrap_or("").to_string(),
          block_number,
          amount: amount_hex.to_string(),
          amount_decimal,
        });
      }
    }
  }

  if checked_count > 0 && deposits.is_empty() {
    info!("[Analyzer] Î∏îÎ°ù #{}: {}Í∞ú Ìä∏ÎûúÏû≠ÏÖò ÌôïÏù∏, Í≥†Í∞ù Í≥ÑÏ†ï ÏóÜÏùå", block_number, checked_count);
  }

  Ok((chain_name.to_string(), block_number, deposits))
}

async fn analyze_bitcoin_block(
  block: crate::coin::bitcoin::model::BitcoinBlock,
  repository: &Arc<RepositoryWrapper>,
  kv_db: Option<&KeyValueDB>,
) -> Result<(String, u64, Vec<DepositInfo>), String> {
  let chain_name = "BTC";
  let block_number = block.height;
  
  info!("[Analyzer] Bitcoin Block Received: {}", block_number);
  
  let mut deposits = Vec::new();
  
  for tx in &block.tx {
    for output in &tx.out {
      if let Some(address) = &output.addr {
        if let Ok(true) = is_monitored_address(repository, kv_db, address, chain_name).await {
          let amount_decimal = Decimal::from(output.value) / Decimal::from(100_000_000u64); // satoshi to BTC

          deposits.push(DepositInfo {
            address: address.clone(),
            tx_hash: tx.hash.clone(),
            block_number,
            amount: output.value.to_string(),
            amount_decimal: Some(amount_decimal),
          });
        }
      }
    }
  }
  
  Ok((chain_name.to_string(), block_number, deposits))
}

async fn analyze_tron_block(
  block: crate::coin::tron::model::TronBlock,
  repository: &Arc<RepositoryWrapper>,
  kv_db: Option<&KeyValueDB>,
) -> Result<(String, u64, Vec<DepositInfo>), String> {
  let chain_name = "TRON";
  let block_number = block.block_header.raw_data.number;
  
  info!("[Analyzer] TRON Block Received: {}", block_number);
  
  let mut deposits = Vec::new();
  
  for tx in &block.transactions {
    // TRX ?? ??
    if let Some(contract) = tx.raw_data.contract.first() {
      if contract.contract_type == "TransferContract" {
        if let Some(to_address) = &contract.parameter.value.to_address {
          if let Ok(true) = is_monitored_address(repository, kv_db, to_address, chain_name).await {
            let amount = contract.parameter.value.amount.unwrap_or(0);
            let amount_decimal = Decimal::from(amount) / Decimal::from(1_000_000u64); // SUN to TRX
            
            deposits.push(DepositInfo {
              address: to_address.clone(),
              tx_hash: tx.tx_id.clone(),
              block_number,
              amount: amount.to_string(),
              amount_decimal: Some(amount_decimal),
            });
          }
        }
      }
    }
  }
  
  Ok((chain_name.to_string(), block_number, deposits))
}

async fn analyze_theta_block(
  block: crate::coin::theta::model::ThetaBlock,
  repository: &Arc<RepositoryWrapper>,
  kv_db: Option<&KeyValueDB>,
) -> Result<(String, u64, Vec<DepositInfo>), String> {
  let chain_name = "THETA";
  let block_number = block.height.parse::<u64>()
    .map_err(|e| format!("Failed to parse THETA block number: {}", e))?;

  info!("[Analyzer] THETA Block Received: {}", block_number);

  let mut deposits = Vec::new();

  // THETA Ìä∏ÎûúÏû≠ÏÖò Î∂ÑÏÑù (Ethereum Ìò∏Ìôò RPC ÌòïÏãù)
  for tx in &block.transactions {
    if let Some(to_address) = &tx.to {
      if let Ok(true) = is_monitored_address(repository, kv_db, to_address, chain_name).await {
        // valueÎäî Wei Îã®ÏúÑ (1 THETA = 10^18 Wei)
        let value_hex = if tx.value.starts_with("0x") {
          &tx.value
        } else {
          &format!("0x{}", tx.value)
        };

        let amount_decimal = parse_wei_to_decimal(value_hex).ok();

        deposits.push(DepositInfo {
          address: to_address.clone(),
          tx_hash: tx.hash.clone(),
          block_number,
          amount: tx.value.clone(),
          amount_decimal,
        });
      }
    }
  }

  if !deposits.is_empty() {
    info!("[Analyzer] Found {} THETA deposits in block {}", deposits.len(), block_number);
  }

  Ok((chain_name.to_string(), block_number, deposits))
}

async fn analyze_icon_block(
  block: crate::coin::icon::model::IconBlock,
  repository: &Arc<RepositoryWrapper>,
  kv_db: Option<&KeyValueDB>,
) -> Result<(String, u64, Vec<DepositInfo>), String> {
  let chain_name = "ICON";
  let block_number = block.height;

  info!("[Analyzer] ICON Block Received: {}", block_number);

  let mut deposits = Vec::new();

  for tx in &block.confirmed_transaction_list {
    let to_address = &tx.to;

      if let Ok(true) = is_monitored_address(repository, kv_db, to_address, chain_name).await {
      let amount_decimal = tx.value.as_ref()
        .and_then(|v| v.parse::<u64>().ok())
        .map(|v| Decimal::from(v) / Decimal::from(1_000_000_000_000_000_000u64)); // Loop to ICX

      deposits.push(DepositInfo {
        address: to_address.clone(),
        tx_hash: tx.tx_hash.clone(),
        block_number,
        amount: tx.value.clone().unwrap_or_default(),
        amount_decimal,
      });
    }
  }

  Ok((chain_name.to_string(), block_number, deposits))
}

async fn analyze_aion_block(
  block: crate::coin::aion::model::AionBlock,
  repository: &Arc<RepositoryWrapper>,
  kv_db: Option<&KeyValueDB>,
) -> Result<(String, u64, Vec<DepositInfo>), String> {
  let chain_name = "AION";
  let result = block.result.ok_or("Missing 'result' in AionBlock")?;

  let number_hex = result.number.trim();
  let block_number = if number_hex.starts_with("0x") {
    u64::from_str_radix(&number_hex[2..], 16)
  } else {
    number_hex.parse::<u64>()
  }.map_err(|e| format!("Failed to parse AION block number: {}", e))?;

  info!("[Analyzer] üîç AION Î∏îÎ°ù #{} Ïä§Ï∫î Ï§ë... (Ìä∏ÎûúÏû≠ÏÖò: {}Í∞ú)", block_number, result.transactions.len());

  let mut deposits = Vec::new();
  let mut checked_count = 0;

  for tx in &result.transactions {
    if let Some(to_address) = &tx.to {
      checked_count += 1;
      if let Ok(true) = is_monitored_address(repository, kv_db, to_address, chain_name).await {
        let amount_hex = tx.value.as_deref().unwrap_or("0x0");
        let amount_decimal = parse_wei_to_decimal(amount_hex).ok();

        info!("[Analyzer] ‚úÖ AION ÏûÖÍ∏à Í∞êÏßÄ! Î∏îÎ°ù: {} | Ï£ºÏÜå: {} | Í∏àÏï°: {:?} AION",
          block_number, to_address, amount_decimal);

        deposits.push(DepositInfo {
          address: to_address.clone(),
          tx_hash: tx.hash.as_deref().unwrap_or("").to_string(),
          block_number,
          amount: amount_hex.to_string(),
          amount_decimal,
        });
      }
    }
  }

  if checked_count > 0 && deposits.is_empty() {
    info!("[Analyzer] AION Î∏îÎ°ù #{}: {}Í∞ú Ìä∏ÎûúÏû≠ÏÖò ÌôïÏù∏, Í≥†Í∞ù Í≥ÑÏ†ï ÏóÜÏùå", block_number, checked_count);
  }

  Ok((chain_name.to_string(), block_number, deposits))
}

async fn analyze_algorand_block(
  block: crate::coin::algorand::model::AlgorandBlock,
  repository: &Arc<RepositoryWrapper>,
  kv_db: Option<&KeyValueDB>,
) -> Result<(String, u64, Vec<DepositInfo>), String> {
  let chain_name = "ALGORAND";
  let block_number = block.round;

  info!("[Analyzer] ALGORAND Block Received: {}", block_number);

  let mut deposits = Vec::new();

  for tx in &block.txns.transactions {
    if let Some(payment) = &tx.payment {
      let to_address = &payment.to;

      if let Ok(true) = is_monitored_address(repository, kv_db, to_address, chain_name).await {
        // Algorand uses microalgos (1 ALGO = 1,000,000 microalgos)
        let amount_decimal = Decimal::from(payment.amount) / Decimal::from(1_000_000u64);

        info!("[Analyzer] ‚úÖ ALGORAND ÏûÖÍ∏à Í∞êÏßÄ! Î∏îÎ°ù: {} | Ï£ºÏÜå: {} | Í∏àÏï°: {} ALGO",
          block_number, to_address, amount_decimal);

        deposits.push(DepositInfo {
          address: to_address.clone(),
          tx_hash: tx.tx.clone(),
          block_number,
          amount: payment.amount.to_string(),
          amount_decimal: Some(amount_decimal),
        });
      }
    }
  }

  if !deposits.is_empty() {
    info!("[Analyzer] Found {} ALGORAND deposits in block {}", deposits.len(), block_number);
  }

  Ok((chain_name.to_string(), block_number, deposits))
}

async fn process_deposit(
  repository: &Arc<RepositoryWrapper>,
  chain_name: &str,
  deposit: DepositInfo,
  current_block: u64,
  required_confirmations: u64,
  sqs_notifier: Option<&SqsNotifier>,
) -> Result<(), String> {
  let confirmations = current_block.saturating_sub(deposit.block_number) + 1;

  info!(
    "[DEPOSIT] Received {} {} at address {} (tx: {}, block: {}, confirmations: {})",
    deposit.amount, chain_name, deposit.address, deposit.tx_hash, deposit.block_number, confirmations
  );

  // Check if deposit already exists in database
  let already_exists = repository
    .deposit_exists(&deposit.tx_hash, chain_name)
    .await
    .map_err(|e| format!("Failed to check deposit existence: {}", e))?;

  if already_exists {
    // Deposit already processed in Stage 1, only check Stage 2
    if confirmations >= required_confirmations {
      // Check if already confirmed to prevent duplicate notifications
      let is_confirmed = repository
        .is_deposit_confirmed(&deposit.tx_hash)
        .await
        .map_err(|e| format!("Failed to check confirmation status: {}", e))?;

      if !is_confirmed {
        info!("[DEPOSIT_CONFIRMED] {} confirmations reached (required: {}), sending confirmation", confirmations, required_confirmations);

        // Update deposit confirmed status
        repository.update_deposit_confirmed(&deposit.tx_hash)
          .await
          .map_err(|e| format!("Failed to update deposit confirmation: {}", e))?;

        // Send SQS notification
        if let Some(notifier) = sqs_notifier {
          if let Err(e) = notifier.send_deposit_confirmed(
            deposit.address.clone(),
            chain_name.to_uppercase(),
            deposit.tx_hash.clone(),
            deposit.amount.clone(),
            deposit.block_number,
            confirmations,
          ).await {
            error!("[DEPOSIT_CONFIRMED] Failed to send SQS: {}", e);
          } else {
            info!("[DEPOSIT_CONFIRMED] ‚úÖ SQS notification sent");
          }
        }
      } else {
        // Already confirmed, skip
        return Ok(());
      }
    }
    return Ok(());
  }

  // New deposit - Stage 1: DEPOSIT_DETECTED (1 confirmation)
  if confirmations == 1 {
    info!("[DEPOSIT_DETECTED] {} confirmations reached for tx {}", confirmations, deposit.tx_hash);

    // Save to DB with status PENDING
    repository.save_deposit_event(
      &deposit.address,
      chain_name,
      &deposit.tx_hash,
      deposit.block_number,
      &deposit.amount,
      deposit.amount_decimal,
    )
    .await
    .map_err(|e| format!("Failed to save deposit event: {}", e))?;

    // Send SQS notification
    if let Some(notifier) = sqs_notifier {
      if let Err(e) = notifier.send_deposit_detected(
        deposit.address.clone(),
        chain_name.to_uppercase(),
        deposit.tx_hash.clone(),
        deposit.amount.clone(),
        deposit.block_number,
      ).await {
        error!("[DEPOSIT_DETECTED] Failed to send SQS: {}", e);
      } else {
        info!("[DEPOSIT_DETECTED] ‚úÖ SQS notification sent");
      }
    }
  }

  Ok(())
}

// Wei? Decimal? ??
fn parse_wei_to_decimal(wei_hex: &str) -> Result<Decimal, String> {
  let wei_str = if wei_hex.starts_with("0x") || wei_hex.starts_with("0X") {
    &wei_hex[2..]
  } else {
    wei_hex
  };
  
  let wei = u128::from_str_radix(wei_str, 16)
    .map_err(|e| format!("Failed to parse wei: {}", e))?;
  
  // Wei? ETH? ?? (1 ETH = 10^18 Wei)
  let eth = Decimal::from(wei) / Decimal::from(1_000_000_000_000_000_000u128);

  Ok(eth)
}

// GXCHAIN, QUARK, TERRA, TEZOS, WAYKI placeholder functions
async fn analyze_gxchain_block(
  _block: crate::coin::gxchain::model::GxchainBlock,
  _repository: &Arc<RepositoryWrapper>,
  _kv_db: Option<&KeyValueDB>,
) -> Result<(String, u64, Vec<DepositInfo>), String> {
  info!("[Analyzer] GXCHAIN block received (placeholder - not yet implemented)");
  Ok(("GXCHAIN".to_string(), 0, Vec::new()))
}

async fn analyze_quark_block(
  block: crate::coin::quark::model::QuarkBlock,
  repository: &Arc<RepositoryWrapper>,
  kv_db: Option<&KeyValueDB>,
) -> Result<(String, u64, Vec<DepositInfo>), String> {
  let chain_name = "QUARK";
  let result = block.result.ok_or("Missing 'result' in QuarkBlock")?;

  let number_hex = result.number.trim();
  let block_number = if number_hex.starts_with("0x") {
    u64::from_str_radix(&number_hex[2..], 16)
  } else {
    number_hex.parse::<u64>()
  }.map_err(|e| format!("Failed to parse QUARK block number: {}", e))?;

  info!("[Analyzer] QUARK Block Received: {}", block_number);

  let mut deposits = Vec::new();

  for tx in &result.transactions {
    if let Some(to_address) = &tx.to {
      if let Ok(true) = is_monitored_address(repository, kv_db, to_address, chain_name).await {
        let amount_hex = tx.value.as_deref().unwrap_or("0x0");
        let amount_decimal = parse_wei_to_decimal(amount_hex).ok();

        deposits.push(DepositInfo {
          address: to_address.clone(),
          tx_hash: tx.hash.as_deref().unwrap_or("").to_string(),
          block_number,
          amount: amount_hex.to_string(),
          amount_decimal,
        });
      }
    }
  }

  Ok((chain_name.to_string(), block_number, deposits))
}

async fn analyze_terra_block(
  block: crate::coin::terra::model::TerraBlock,
  _repository: &Arc<RepositoryWrapper>,
  _kv_db: Option<&KeyValueDB>,
) -> Result<(String, u64, Vec<DepositInfo>), String> {
  let chain_name = "TERRA";
  let block_number = block.block.header.height.parse::<u64>()
    .map_err(|e| format!("Failed to parse TERRA block number: {}", e))?;

  info!("[Analyzer] TERRA Block Received: {} (placeholder)", block_number);
  Ok((chain_name.to_string(), block_number, Vec::new()))
}

async fn analyze_tezos_block(
  _block: crate::coin::tezos::model::TezosBlock,
  _repository: &Arc<RepositoryWrapper>,
  _kv_db: Option<&KeyValueDB>,
) -> Result<(String, u64, Vec<DepositInfo>), String> {
  info!("[Analyzer] TEZOS block received (placeholder - not yet implemented)");
  Ok(("TEZOS".to_string(), 0, Vec::new()))
}

async fn analyze_wayki_block(
  block: crate::coin::wayki::model::WaykiBlock,
  _repository: &Arc<RepositoryWrapper>,
  _kv_db: Option<&KeyValueDB>,
) -> Result<(String, u64, Vec<DepositInfo>), String> {
  let chain_name = "WAYKI";
  let block_number = block.height;

  info!("[Analyzer] WAYKI Block Received: {} (placeholder)", block_number);
  Ok((chain_name.to_string(), block_number, Vec::new()))
}
